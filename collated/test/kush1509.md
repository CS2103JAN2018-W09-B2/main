# kush1509
###### /java/systemtests/job/JobAddCommandSystemTest.java
``` java
package systemtests.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_ALGORITHMS;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_INTERN;
import static seedu.address.testutil.TypicalJobs.DEVELOPER_INTERN;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.Model;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.job.exceptions.DuplicateJobException;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.JobBuilder;
import seedu.address.testutil.JobUtil;
import systemtests.AddressBookSystemTest;

public class JobAddCommandSystemTest extends AddressBookSystemTest {

    @Test
    public void add() throws Exception {
        Model model = getModel();

        /* ------------------------ Perform add operations on the shown unfiltered list ----------------------------- */

        /* Case: add a job to a non-empty address book, command with leading spaces and trailing spaces
         * -> added
         */
        Job toAdd = DEVELOPER_INTERN;
        String command = "   " + JobAddCommand.COMMAND_WORD + "  " + POSITION_DESC_DEVELOPER_INTERN + " "
                + TEAM_DESC_DEVELOPER_INTERN + " " + LOCATION_DESC_DEVELOPER_INTERN + " "
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + " " + SKILL_DESC_JAVASCRIPT + " " + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: undo adding Software Engineer to the list -> Software Engineer deleted */
        command = UndoCommand.COMMAND_WORD;
        String expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: redo adding Software Engineer to the list -> Software Engineer added again */
        command = RedoCommand.COMMAND_WORD;
        model.addJob(toAdd);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, model, expectedResultMessage);

        /* Case: add a job with all fields same as another job in the address book except position -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except team -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except location -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_INTERN).withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* Case: add a job with all fields same as another job in the address book except numberOfPositions -> added */
        toAdd = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN).withTeam(VALID_TEAM_DEVELOPER_INTERN)
                .withLocation(VALID_LOCATION_DEVELOPER_INTERN).withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_INTERN)
                .withSkills(VALID_SKILL_JAVASCRIPT, VALID_SKILL_ALGORITHMS).build();
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_JAVASCRIPT
                + SKILL_DESC_ALGORITHMS;
        assertCommandSuccess(command, toAdd);

        /* ----------------------------------- Perform invalid add operations --------------------------------------- */

        /* Case: add a duplicate job -> rejected */
        command = JobUtil.getJobAddCommand(DEVELOPER_INTERN);
        assertCommandFailure(command, JobAddCommand.MESSAGE_DUPLICATE_JOB);

        /* Case: missing position -> rejected */
        command = JobAddCommand.COMMAND_WORD + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing team -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + LOCATION_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing location -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing numberOfPositions -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN + LOCATION_DESC_INTERN
                + SKILL_DESC_EXCEL;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: missing tags -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN;
        assertCommandFailure(command, String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE));

        /* Case: invalid keyword -> rejected */
        command = "adds " + JobUtil.getJobDetails(toAdd);
        assertCommandFailure(command, Messages.MESSAGE_UNKNOWN_COMMAND);

        /* Case: invalid position -> rejected */
        command = JobAddCommand.COMMAND_WORD + INVALID_POSITION_DESC + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Position.MESSAGE_POSITION_CONSTRAINTS);

        /* Case: invalid team -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + INVALID_TEAM_DESC
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Team.MESSAGE_TEAM_CONSTRAINTS);

        /* Case: invalid location -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + INVALID_LOCATION_DESC + NUMBER_OF_POSITIONS_DESC_INTERN + SKILL_DESC_EXCEL;
        assertCommandFailure(command, Location.MESSAGE_LOCATION_CONSTRAINTS);

        /* Case: invalid numberOfPositions -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + INVALID_NUMBER_OF_POSITIONS_DESC + SKILL_DESC_EXCEL;
        assertCommandFailure(command, NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS);

        /* Case: invalid skill -> rejected */
        command = JobAddCommand.COMMAND_WORD + POSITION_DESC_INTERN + TEAM_DESC_INTERN
                + LOCATION_DESC_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN + INVALID_SKILL_DESC;
        assertCommandFailure(command, Skill.MESSAGE_SKILL_CONSTRAINTS);
    }

    /**
     * Executes the {@code JobAddCommand} that adds {@code toAdd} to the model and asserts that the,<br>
     * 1. Command box displays an empty string.<br>
     * 2. Command box has the default style class.<br>
     * 3. Result display box displays the success message of executing {@code JobAddCommand} with the details of
     * {@code toAdd}.<br>
     * 4. {@code Model}, {@code Storage} and {@code JobListPanel} equal to the corresponding components in
     * the current model added with {@code toAdd}.<br>
     * 5. Browser url and selected card remain unchanged.<br>
     * 6. Status bar's sync status changes.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(Job toAdd) {
        assertCommandSuccess(JobUtil.getJobAddCommand(toAdd), toAdd);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(Job)}. Executes {@code command}
     * instead.
     * @see JobAddCommandSystemTest#assertCommandSuccess(Job)
     */
    private void assertCommandSuccess(String command, Job toAdd) {
        Model expectedModel = getModel();
        try {
            expectedModel.addJob(toAdd);
        } catch (DuplicateJobException dpe) {
            throw new IllegalArgumentException("toAdd already exists in the model.");
        }
        String expectedResultMessage = String.format(JobAddCommand.MESSAGE_SUCCESS, toAdd);

        assertCommandSuccess(command, expectedModel, expectedResultMessage);
    }

    /**
     * Performs the same verification as {@code assertCommandSuccess(String, Job)} except asserts that
     * the,<br>
     * 1. Result display box displays {@code expectedResultMessage}.<br>
     * 2. {@code Model}, {@code Storage} and {@code JobListPanel} equal to the corresponding components in
     * {@code expectedModel}.<br>
     * @see JobAddCommandSystemTest#assertCommandSuccess(String, Job)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        executeCommand(command);
        assertApplicationDisplaysExpected("", expectedResultMessage, expectedModel);
        assertSelectedJobCardUnchanged();
        assertCommandBoxShowsDefaultStyle();
        assertStatusBarUnchangedExceptSyncStatus();
    }

    /**
     * Executes {@code command} and asserts that the,<br>
     * 1. Command box displays {@code command}.<br>
     * 2. Command box has the error style class.<br>
     * 3. Result display box displays {@code expectedResultMessage}.<br>
     * 4. {@code Model}, {@code Storage} and {@code JobListPanel} remain unchanged.<br>
     * 5. Browser url, selected card and status bar remain unchanged.<br>
     * Verifications 1, 3 and 4 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.<br>
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandFailure(String command, String expectedResultMessage) {
        Model expectedModel = getModel();

        executeCommand(command);
        assertApplicationDisplaysExpected(command, expectedResultMessage, expectedModel);
        assertSelectedJobCardUnchanged();
        assertCommandBoxShowsErrorStyle();
        assertStatusBarUnchanged();
    }
}
```
###### /java/systemtests/job/JobDeleteCommandSystemTest.java
``` java
package systemtests.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;
import static seedu.address.logic.commands.job.JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS;
import static seedu.address.testutil.TestUtil.getJob;
import static seedu.address.testutil.TestUtil.getLastJobIndex;
import static seedu.address.testutil.TestUtil.getMidJobIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.job.JobDeleteCommand;
import seedu.address.model.Model;
import seedu.address.model.job.Job;
import seedu.address.model.job.exceptions.JobNotFoundException;
import systemtests.AddressBookSystemTest;

public class JobDeleteCommandSystemTest extends AddressBookSystemTest {

    private static final String MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT =
            String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, JobDeleteCommand.MESSAGE_USAGE);

    @Test
    public void delete() {
        /* ----------------- Performing delete operation while an unfiltered list is being shown -------------------- */

        /* Case: delete the first Job in the list, command with leading spaces and trailing spaces -> deleted */
        Model expectedModel = getModel();
        String command = "     " + JobDeleteCommand.COMMAND_WORD + "      " + INDEX_FIRST.getOneBased() + "       ";
        Job deletedJob = removeJob(expectedModel, INDEX_FIRST);
        String expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);
        assertCommandSuccess(command, expectedModel, expectedResultMessage);

        /* Case: delete the last Job in the list -> deleted */
        Model modelBeforeDeletingLast = getModel();
        Index lastJobIndex = getLastJobIndex(modelBeforeDeletingLast);
        assertCommandSuccess(lastJobIndex);

        /* Case: undo deleting the last Job in the list -> last Job restored */
        command = UndoCommand.COMMAND_WORD;
        expectedResultMessage = UndoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);

        /* Case: redo deleting the last Job in the list -> last Job deleted again */
        command = RedoCommand.COMMAND_WORD;
        removeJob(modelBeforeDeletingLast, lastJobIndex);
        expectedResultMessage = RedoCommand.MESSAGE_SUCCESS;
        assertCommandSuccess(command, modelBeforeDeletingLast, expectedResultMessage);

        /* Case: delete the middle Job in the list -> deleted */
        Index middleJobIndex = getMidJobIndex(getModel());
        assertCommandSuccess(middleJobIndex);

        /* ------------------ Performing delete operation while a filtered list is being shown ---------------------- */

        //        /* Case: filtered Job list, delete index within bounds of address book and Job list -> deleted */
        //        showJobsWithName(KEYWORD_MATCHING_MEIER);
        //        Index index = INDEX_FIRST;
        //        assertTrue(index.getZeroBased() < getModel().getFilteredJobList().size());
        //        assertCommandSuccess(index);
        //
        //        /* Case: filtered Job list, delete index within bounds of address book but out of bounds of Job list
        //         * -> rejected
        //         */
        //        showJobsWithName(KEYWORD_MATCHING_MEIER);
        //        int invalidIndex = getModel().getAddressBook().getJobList().size();
        //        command = JobDeleteCommand.COMMAND_WORD + " " + invalidIndex;
        //        assertCommandFailure(command, MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
        //
        // /* --------------------- Performing delete operation while a Job card is selected ------------------------ */
        //
        //        /* Case: delete the selected Job -> Job list panel selects the Job before the deleted Job */
        //        showAllJobs();
        //        expectedModel = getModel();
        //        Index selectedIndex = getLastPersonIndex(expectedModel);
        //        Index expectedIndex = Index.fromZeroBased(selectedIndex.getZeroBased() - 1);
        //        selectJob(selectedIndex);
        //        command = JobDeleteCommand.COMMAND_WORD + " " + selectedIndex.getOneBased();
        //        deletedJob = removeJob(expectedModel, selectedIndex);
        //        expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);
        //        assertCommandSuccess(command, expectedModel, expectedResultMessage, expectedIndex);

        /* --------------------------------- Performing invalid delete operation ------------------------------------ */

        /* Case: invalid index (0) -> rejected */
        command = JobDeleteCommand.COMMAND_WORD + " 0";
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid index (-1) -> rejected */
        command = JobDeleteCommand.COMMAND_WORD + " -1";
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid index (size + 1) -> rejected */
        Index outOfBoundsIndex = Index.fromOneBased(
                getModel().getAddressBook().getJobList().size() + 1);
        command = JobDeleteCommand.COMMAND_WORD + " " + outOfBoundsIndex.getOneBased();
        assertCommandFailure(command, MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        /* Case: invalid arguments (alphabets) -> rejected */
        assertCommandFailure(JobDeleteCommand.COMMAND_WORD + " abc",
                MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: invalid arguments (extra argument) -> rejected */
        assertCommandFailure(JobDeleteCommand.COMMAND_WORD + " 1 abc",
                MESSAGE_INVALID_JOB_DELETE_COMMAND_FORMAT);

        /* Case: mixed case command word -> rejected */
        assertCommandFailure("DelETE 1", MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Removes the {@code Job} at the specified {@code index} in {@code model}'s address book.
     * @return the removed Job
     */
    private Job removeJob(Model model, Index index) {
        Job targetJob = getJob(model, index);
        try {
            model.deleteJob(targetJob);
        } catch (JobNotFoundException pnfe) {
            throw new AssertionError("targetJob is retrieved from model.");
        }
        return targetJob;
    }

    /**
     * JobDeletes the Job at {@code toJobDelete} by creating a default {@code JobDeleteCommand}
     * using {@code toJobDelete} and performs the same verification as
     * {@code assertCommandSuccess(String, Model, String)}.
     * @see JobDeleteCommandSystemTest#assertCommandSuccess(String, Model, String)
     */
    private void assertCommandSuccess(Index toJobDelete) {
        Model expectedModel = getModel();
        Job deletedJob = removeJob(expectedModel, toJobDelete);
        String expectedResultMessage = String.format(MESSAGE_DELETE_JOB_SUCCESS, deletedJob);

        assertCommandSuccess(
                JobDeleteCommand.COMMAND_WORD + " " + toJobDelete.getOneBased(), expectedModel, expectedResultMessage);
    }

    /**
     * Executes {@code command} and in addition,<br>
     * 1. Asserts that the command box displays an empty string.<br>
     * 2. Asserts that the result display box displays {@code expectedResultMessage}.<br>
     * 3. Asserts that the model related components equal to {@code expectedModel}.<br>
     * 4. Asserts that the browser url and selected card remains unchanged.<br>
     * 5. Asserts that the status bar's sync status changes.<br>
     * 6. Asserts that the command box has the default style class.<br>
     * Verifications 1 to 3 are performed by
     * {@code AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)}.
     * @see AddressBookSystemTest#assertApplicationDisplaysExpected(String, String, Model)
     */
    private void assertCommandSuccess(String command, Model expectedModel, String expectedResultMessage) {
        assertCommandSuccess(command, expectedModel, expectedResultMessage, null);
    }

```
###### /java/systemtests/AddressBookSystemTest.java
``` java
    public JobListPanelHandle getJobListPanel() {
        return mainWindowHandle.getJobListPanel();
    }

    public MainMenuHandle getMainMenu() {
        return mainWindowHandle.getMainMenu();
    }

    public BrowserPanelHandle getBrowserPanel() {
        return mainWindowHandle.getBrowserPanel();
    }

    public StatusBarFooterHandle getStatusBarFooter() {
        return mainWindowHandle.getStatusBarFooter();
    }

    public ResultDisplayHandle getResultDisplay() {
        return mainWindowHandle.getResultDisplay();
    }

    /**
     * Executes {@code command} in the application's {@code CommandBox}.
     * Method returns after UI components have been updated.
     */
    protected void executeCommand(String command) {
        rememberStates();
        // Injects a fixed clock before executing a command so that the time stamp shown in the status bar
        // after each command is predictable and also different from the previous command.
        clockRule.setInjectedClockToCurrentTime();

        mainWindowHandle.getCommandBox().run(command);
    }

    /**
     * Displays all persons in the address book.
     */
    protected void showAllPersons() {
        executeCommand(ListCommand.COMMAND_WORD);
        assertEquals(getModel().getAddressBook().getPersonList().size(), getModel().getFilteredPersonList().size());
    }

    /**
     * Displays all persons with any parts of their names matching {@code keyword} (case-insensitive).
     */
    protected void showPersonsWithName(String keyword) {
        executeCommand(FindCommand.COMMAND_WORD + " n/" + keyword);
        assertTrue(getModel().getFilteredPersonList().size() < getModel().getAddressBook().getPersonList().size());
    }

    /**
     * Selects the person at {@code index} of the displayed list.
     */
    protected void selectPerson(Index index) {
        executeCommand(SelectCommand.COMMAND_WORD + " " + index.getOneBased());
        assertEquals(index.getZeroBased(), getPersonListPanel().getSelectedCardIndex());
    }

    /**
     * Deletes all persons in the address book.
     */
    protected void deleteAllPersons() {
        executeCommand(ClearCommand.COMMAND_WORD);
        assertEquals(0, getModel().getAddressBook().getPersonList().size());
    }

    /**
     * Asserts that the {@code CommandBox} displays {@code expectedCommandInput}, the {@code ResultDisplay} displays
     * {@code expectedResultMessage}, the model and storage contains the same person objects as {@code expectedModel}
     * and the person list panel displays the persons in the model correctly.
     */
    protected void assertApplicationDisplaysExpected(String expectedCommandInput, String expectedResultMessage,
            Model expectedModel) {
        assertEquals(expectedCommandInput, getCommandBox().getInput());
        assertEquals(expectedResultMessage, getResultDisplay().getText());
        assertEquals(expectedModel, getModel());
        assertEquals(expectedModel.getAddressBook(), testApp.readStorageAddressBook());
        assertListMatching(getPersonListPanel(), expectedModel.getFilteredPersonList());
    }

    /**
     * Calls {@code BrowserPanelHandle}, {@code PersonListPanelHandle} and {@code StatusBarFooterHandle} to remember
     * their current state.
     */
    private void rememberStates() {
        StatusBarFooterHandle statusBarFooterHandle = getStatusBarFooter();
        getBrowserPanel().rememberUrl();
        statusBarFooterHandle.rememberSaveLocation();
        statusBarFooterHandle.rememberSyncStatus();
        getPersonListPanel().rememberSelectedPersonCard();
        getJobListPanel().rememberSelectedJobCard();
    }

    /**
     * Asserts that the previously selected card is now deselected and the browser's url remains displaying the details
     * of the previously selected person.
     * @see BrowserPanelHandle#isUrlChanged()
     */
    protected void assertSelectedCardDeselected() {
        assertFalse(getBrowserPanel().isUrlChanged());
        assertFalse(getPersonListPanel().isAnyCardSelected());
    }

    /**
     * Asserts that the previously selected job card is now deselected.
     */
    protected void assertSelectedJobCardDeselected() {
        assertFalse(getJobListPanel().isAnyCardSelected());
    }

    /**
     * Asserts that the browser's url is changed to display the details of the person in the person list panel at
     * {@code expectedSelectedCardIndex}, and only the card at {@code expectedSelectedCardIndex} is selected.
     * @see BrowserPanelHandle#isUrlChanged()
     * @see PersonListPanelHandle#isSelectedPersonCardChanged()
     */
    protected void assertSelectedCardChanged(Index expectedSelectedCardIndex) {
        String selectedCardName = getPersonListPanel().getHandleToSelectedCard().getName();
        URL expectedUrl;
        try {
            expectedUrl = new URL(BrowserPanel.SEARCH_PAGE_URL + selectedCardName.replaceAll(" ", "%20"));
        } catch (MalformedURLException mue) {
            throw new AssertionError("URL expected to be valid.");
        }
        assertEquals(expectedUrl, getBrowserPanel().getLoadedUrl());

        assertEquals(expectedSelectedCardIndex.getZeroBased(), getPersonListPanel().getSelectedCardIndex());
    }

    /**
     * Asserts that the browser's url and the selected card in the person list panel remain unchanged.
     * @see BrowserPanelHandle#isUrlChanged()
     * @see PersonListPanelHandle#isSelectedPersonCardChanged()
     */
    protected void assertSelectedCardUnchanged() {
        assertFalse(getBrowserPanel().isUrlChanged());
        assertFalse(getPersonListPanel().isSelectedPersonCardChanged());
    }

    /**
     * Asserts that the selected card in the job list panel remain unchanged.
     * @see JobListPanelHandle#isSelectedJobCardChanged()
     */
    protected void assertSelectedJobCardUnchanged() {
        assertFalse(getJobListPanel().isSelectedJobCardChanged());
    }

    /**
     * Asserts that the command box's shows the default style.
     */
    protected void assertCommandBoxShowsDefaultStyle() {
        assertEquals(COMMAND_BOX_DEFAULT_STYLE, getCommandBox().getStyleClass());
    }

    /**
     * Asserts that the command box's shows the error style.
     */
    protected void assertCommandBoxShowsErrorStyle() {
        assertEquals(COMMAND_BOX_ERROR_STYLE, getCommandBox().getStyleClass());
    }

    /**
     * Asserts that the entire status bar remains the same.
     */
    protected void assertStatusBarUnchanged() {
        StatusBarFooterHandle handle = getStatusBarFooter();
        assertFalse(handle.isSaveLocationChanged());
        assertFalse(handle.isSyncStatusChanged());
    }

    /**
     * Asserts that only the sync status in the status bar was changed to the timing of
     * {@code ClockRule#getInjectedClock()}, while the save location remains the same.
     */
    protected void assertStatusBarUnchangedExceptSyncStatus() {
        StatusBarFooterHandle handle = getStatusBarFooter();
        String timestamp = new Date(clockRule.getInjectedClock().millis()).toString();
        String expectedSyncStatus = String.format(SYNC_STATUS_UPDATED, timestamp);
        assertEquals(expectedSyncStatus, handle.getSyncStatus());
        assertFalse(handle.isSaveLocationChanged());
    }

    /**
     * Asserts that the starting state of the application is correct.
     */
    private void assertApplicationStartingStateIsCorrect() {
        try {
            assertEquals("", getCommandBox().getInput());
            assertEquals("", getResultDisplay().getText());
            assertListMatching(getPersonListPanel(), getModel().getFilteredPersonList());
            assertListMatching(getJobListPanel(), getModel().getFilteredJobList());
            assertEquals(BrowserPanel.DEFAULT_PAGE_URL, getBrowserPanel().getLoadedUrl().toString());
            assertEquals("./" + testApp.getStorageSaveLocation(), getStatusBarFooter().getSaveLocation());
            assertEquals(SYNC_STATUS_INITIAL, getStatusBarFooter().getSyncStatus());
        } catch (Exception e) {
            throw new AssertionError("Starting state is wrong.", e);
        }
    }

    /**
     * Returns a defensive copy of the current model.
     */
    protected Model getModel() {
        return testApp.getModel();
    }
}
```
###### /java/seedu/address/logic/commands/job/JobAddCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Test;

import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.job.Job;
import seedu.address.testutil.JobBuilder;

public class JobAddCommandTest {

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void execute_newJob_success() throws Exception {

        Job validJob = new JobBuilder().build();

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.addJob(validJob);

        assertCommandSuccess(prepareCommand(validJob, model), model,
                String.format(JobAddCommand.MESSAGE_SUCCESS, validJob), expectedModel);
    }

    @Test
    public void execute_duplicateJob_throwsCommandException() {
        Job jobInList = model.getAddressBook().getJobList().get(0);
        assertCommandFailure(prepareCommand(jobInList, model), model, JobAddCommand.MESSAGE_DUPLICATE_JOB);
    }

    /**
     * Generates a new {@code JobAddCommand} which upon execution, adds {@code job} into the {@code model}.
     */
    private JobAddCommand prepareCommand(Job job, Model model) {
        JobAddCommand command = new JobAddCommand(job);
        command.setData(model, new CommandHistory(), new UndoRedoStack());
        return command;
    }

}
```
###### /java/seedu/address/logic/commands/job/JobDeleteCommandTest.java
``` java
package seedu.address.logic.commands.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandFailure;
import static seedu.address.logic.commands.CommandTestUtil.assertCommandSuccess;
import static seedu.address.logic.commands.CommandTestUtil.prepareRedoCommand;
import static seedu.address.logic.commands.CommandTestUtil.prepareUndoCommand;
import static seedu.address.logic.commands.CommandTestUtil.showJobAtIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalJobs.getTypicalAddressBook;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.model.job.Job;

/**
 * Contains integration tests (interaction with the Model, UndoCommand and RedoCommand) and unit tests for
 * {@code JobDeleteCommand}.
 */
public class JobDeleteCommandTest {

    private Model model = new ModelManager(getTypicalAddressBook(), new UserPrefs());

    @Test
    public void execute_validIndexUnfilteredList_success() throws Exception {
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);

        String expectedMessage = String.format(JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS, jobToDelete);

        ModelManager expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.deleteJob(jobToDelete);

        assertCommandSuccess(jobDeleteCommand, model, expectedMessage, expectedModel);
    }

    @Test
    public void execute_invalidIndexUnfilteredList_throwsCommandException() throws Exception {
        Index outOfBoundIndex = Index.fromOneBased(model.getFilteredJobList().size() + 1);
        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
    }

    @Test
    public void execute_validIndexFilteredList_success() throws Exception {
        showJobAtIndex(model, INDEX_FIRST);

        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);

        String expectedMessage = String.format(JobDeleteCommand.MESSAGE_DELETE_JOB_SUCCESS, jobToDelete);

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.deleteJob(jobToDelete);
        showNoJob(expectedModel);

        assertCommandSuccess(jobDeleteCommand, model, expectedMessage, expectedModel);
    }

    @Test
    public void execute_invalidIndexFilteredList_throwsCommandException() {
        showJobAtIndex(model, INDEX_FIRST);

        Index outOfBoundIndex = INDEX_SECOND;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getJobList().size());

        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);
    }

    @Test
    public void executeUndoRedo_validIndexUnfilteredList_success() throws Exception {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);
        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());

        // delete -> first job deleted
        jobDeleteCommand.execute();
        undoRedoStack.push(jobDeleteCommand);

        // undo -> reverts addressbook back to previous state and filtered job list to show all jobs
        assertCommandSuccess(undoCommand, model, UndoCommand.MESSAGE_SUCCESS, expectedModel);

        // redo -> same first job deleted again
        expectedModel.deleteJob(jobToDelete);
        assertCommandSuccess(redoCommand, model, RedoCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void executeUndoRedo_invalidIndexUnfilteredList_failure() {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        Index outOfBoundIndex = Index.fromOneBased(model.getFilteredJobList().size() + 1);
        JobDeleteCommand jobDeleteCommand = prepareCommand(outOfBoundIndex);

        // execution failed -> deleteCommand not pushed into undoRedoStack
        assertCommandFailure(jobDeleteCommand, model, Messages.MESSAGE_INVALID_JOB_DISPLAYED_INDEX);

        // no commands in undoRedoStack -> undoCommand and redoCommand fail
        assertCommandFailure(undoCommand, model, UndoCommand.MESSAGE_FAILURE);
        assertCommandFailure(redoCommand, model, RedoCommand.MESSAGE_FAILURE);
    }

    /**
     * 1. Deletes a {@code Job} from a filtered list.
     * 2. Undo the deletion.
     * 3. The unfiltered list should be shown now. Verify that the index of the previously deleted job in the
     * unfiltered list is different from the index at the filtered list.
     * 4. Redo the deletion. This ensures {@code RedoCommand} deletes the job object regardless of indexing.
     */
    @Test
    public void executeUndoRedo_validIndexFilteredList_sameJobDeleted() throws Exception {
        UndoRedoStack undoRedoStack = new UndoRedoStack();
        UndoCommand undoCommand = prepareUndoCommand(model, undoRedoStack);
        RedoCommand redoCommand = prepareRedoCommand(model, undoRedoStack);
        JobDeleteCommand jobDeleteCommand = prepareCommand(INDEX_FIRST);
        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());

        showJobAtIndex(model, INDEX_SECOND);
        Job jobToDelete = model.getFilteredJobList().get(INDEX_FIRST.getZeroBased());
        // delete -> deletes second job in unfiltered job list / first job in filtered job list
        jobDeleteCommand.execute();
        undoRedoStack.push(jobDeleteCommand);

        // undo -> reverts addressbook back to previous state and filtered job list to show all jobs
        assertCommandSuccess(undoCommand, model, UndoCommand.MESSAGE_SUCCESS, expectedModel);

        expectedModel.deleteJob(jobToDelete);
        assertNotEquals(jobToDelete, model.getFilteredJobList().get(INDEX_FIRST.getZeroBased()));
        // redo -> deletes same second job in unfiltered job list
        assertCommandSuccess(redoCommand, model, RedoCommand.MESSAGE_SUCCESS, expectedModel);
    }

    @Test
    public void equals() throws Exception {
        JobDeleteCommand jobDeleteFirstCommand = prepareCommand(INDEX_FIRST);
        JobDeleteCommand jobDeleteSecondCommand = prepareCommand(INDEX_SECOND);

        // same object -> returns true
        assertTrue(jobDeleteFirstCommand.equals(jobDeleteFirstCommand));

        // same values -> returns true
        JobDeleteCommand jobDeleteFirstCommandCopy = prepareCommand(INDEX_FIRST);
        assertTrue(jobDeleteFirstCommand.equals(jobDeleteFirstCommandCopy));

        // one command preprocessed when previously equal -> returns false
        jobDeleteFirstCommandCopy.preprocessUndoableCommand();
        assertFalse(jobDeleteFirstCommand.equals(jobDeleteFirstCommandCopy));

        // different types -> returns false
        assertFalse(jobDeleteFirstCommand.equals(1));

        // null -> returns false
        assertFalse(jobDeleteFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(jobDeleteFirstCommand.equals(jobDeleteSecondCommand));
    }

    /**
     * Returns a {@code JobDeleteCommand} with the parameter {@code index}.
     */
    private JobDeleteCommand prepareCommand(Index index) {
        JobDeleteCommand jobDeleteCommand = new JobDeleteCommand(index);
        jobDeleteCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return jobDeleteCommand;
    }

    /**
     * Updates {@code model}'s filtered job list to show no one.
     */
    private void showNoJob(Model model) {
        model.updateFilteredJobList(p -> false);

        assertTrue(model.getFilteredJobList().isEmpty());
    }

}
```
###### /java/seedu/address/logic/commands/LinkedInCommandTest.java
``` java
package seedu.address.logic.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static seedu.address.logic.commands.CommandTestUtil.showPersonAtIndex;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalIndexes.INDEX_THIRD;
import static seedu.address.testutil.TypicalPersons.getTypicalAddressBook;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.index.Index;
import seedu.address.commons.events.ui.JumpToPersonListRequestEvent;
import seedu.address.logic.CommandHistory;
import seedu.address.logic.UndoRedoStack;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.logic.commands.person.LinkedInCommand;
import seedu.address.model.Model;
import seedu.address.model.ModelManager;
import seedu.address.model.UserPrefs;
import seedu.address.ui.testutil.EventsCollectorRule;

public class LinkedInCommandTest {

    @Rule
    public final EventsCollectorRule eventsCollectorRule = new EventsCollectorRule();

    private Model model;

    @Before
    public void setUp() {
        model = new ModelManager(getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void execute_validIndexUnfilteredList_success() {
        Index lastPersonIndex = Index.fromOneBased(model.getFilteredPersonList().size());

        assertExecutionSuccess(INDEX_FIRST);
        assertExecutionSuccess(INDEX_THIRD);
        assertExecutionSuccess(lastPersonIndex);
    }

    @Test
    public void execute_invalidIndexUnfilteredList_failure() {
        Index outOfBoundsIndex = Index.fromOneBased(model.getFilteredPersonList().size() + 1);

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    @Test
    public void execute_validIndexFilteredList_success() {
        showPersonAtIndex(model, INDEX_FIRST);

        assertExecutionSuccess(INDEX_FIRST);
    }

    @Test
    public void execute_invalidIndexFilteredList_failure() {
        showPersonAtIndex(model, INDEX_FIRST);

        Index outOfBoundsIndex = INDEX_SECOND;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundsIndex.getZeroBased() < model.getAddressBook().getPersonList().size());

        assertExecutionFailure(outOfBoundsIndex, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    @Test
    public void equals() {
        LinkedInCommand linkedInFirstCommand = new LinkedInCommand(INDEX_FIRST);
        LinkedInCommand linkedInSecondCommand = new LinkedInCommand(INDEX_SECOND);

        // same object -> returns true
        assertTrue(linkedInFirstCommand.equals(linkedInFirstCommand));

        // same values -> returns true
        LinkedInCommand linkedInFirstCommandCopy = new LinkedInCommand(INDEX_FIRST);
        assertTrue(linkedInFirstCommand.equals(linkedInFirstCommandCopy));

        // different types -> returns false
        assertFalse(linkedInFirstCommand.equals(1));

        // null -> returns false
        assertFalse(linkedInFirstCommand.equals(null));

        // different person -> returns false
        assertFalse(linkedInFirstCommand.equals(linkedInSecondCommand));
    }

    /**
     * Executes a {@code LinkedInCommand} with the given {@code index}, and checks that
     * {@code JumpToPersonListRequestEvent}
     * is raised with the correct index.
     */
    private void assertExecutionSuccess(Index index) {
        LinkedInCommand linkedInCommand = prepareCommand(index);

        try {
            CommandResult commandResult = linkedInCommand.execute();
            assertEquals(String.format(LinkedInCommand.MESSAGE_LINKEDIN_PERSON_SUCCESS, index.getOneBased()),
                    commandResult.feedbackToUser);
        } catch (CommandException ce) {
            throw new IllegalArgumentException("Execution of command should not fail.", ce);
        }

        JumpToPersonListRequestEvent lastEvent = (JumpToPersonListRequestEvent)
                eventsCollectorRule.eventsCollector.getMostRecent();
        assertEquals(index, Index.fromZeroBased(lastEvent.targetIndex));
    }

    /**
     * Executes a {@code LinkedInCommand} with the given {@code index}, and checks that a {@code CommandException}
     * is thrown with the {@code expectedMessage}.
     */
    private void assertExecutionFailure(Index index, String expectedMessage) {
        LinkedInCommand linkedInCommand = prepareCommand(index);

        try {
            linkedInCommand.execute();
            fail("The expected CommandException was not thrown.");
        } catch (CommandException ce) {
            assertEquals(expectedMessage, ce.getMessage());
            assertTrue(eventsCollectorRule.eventsCollector.isEmpty());
        }
    }

    /**
     * Returns a {@code LinkedInCommand} with parameters {@code index}.
     */
    private LinkedInCommand prepareCommand(Index index) {
        LinkedInCommand linkedInCommand = new LinkedInCommand(index);
        linkedInCommand.setData(model, new CommandHistory(), new UndoRedoStack());
        return linkedInCommand;
    }
}
```
###### /java/seedu/address/logic/parser/job/JobAddCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_LOCATION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_NUMBER_OF_POSITIONS_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_POSITION_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_SKILL_DESC;
import static seedu.address.logic.commands.CommandTestUtil.INVALID_TEAM_DESC;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.LOCATION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.NUMBER_OF_POSITIONS_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.POSITION_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.PREAMBLE_WHITESPACE;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.SKILL_DESC_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.TEAM_DESC_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_LOCATION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_POSITION_DEVELOPER_INTERN;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_EXCEL;
import static seedu.address.logic.commands.CommandTestUtil.VALID_SKILL_JAVASCRIPT;
import static seedu.address.logic.commands.CommandTestUtil.VALID_TEAM_DEVELOPER_INTERN;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;

import org.junit.Test;

import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;
import seedu.address.testutil.JobBuilder;

public class JobAddCommandParserTest {
    private JobAddCommandParser parser = new JobAddCommandParser();

    @Test
    public void parse_allFieldsPresent_success() {
        Job expectedJob = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN)
                .withTeam(VALID_TEAM_DEVELOPER_INTERN).withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN).withSkills(VALID_SKILL_JAVASCRIPT)
                .build();

        // whitespace only preamble
        assertParseSuccess(parser, PREAMBLE_WHITESPACE + POSITION_DESC_DEVELOPER_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple positions - last position accepted
        assertParseSuccess(parser, POSITION_DESC_INTERN + POSITION_DESC_DEVELOPER_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple teams - last team accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_INTERN
                + TEAM_DESC_DEVELOPER_INTERN + LOCATION_DESC_DEVELOPER_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple locations - last location accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_INTERN + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple numberOfPositions - last numberOfPositions accepted
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_INTERN
                + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT, new JobAddCommand(expectedJob));

        // multiple tags - all accepted
        Job expectedJobWithMultipleSkills = new JobBuilder().withPosition(VALID_POSITION_DEVELOPER_INTERN)
                .withTeam(VALID_TEAM_DEVELOPER_INTERN).withLocation(VALID_LOCATION_DEVELOPER_INTERN)
                .withNumberOfPositions(VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN).withSkills(VALID_SKILL_JAVASCRIPT,
                        VALID_SKILL_EXCEL).build();
        assertParseSuccess(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT
                + SKILL_DESC_EXCEL, new JobAddCommand(expectedJobWithMultipleSkills));
    }

    @Test
    public void parse_compulsoryFieldMissing_failure() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobAddCommand.MESSAGE_USAGE);

        // missing position prefix
        assertParseFailure(parser, VALID_POSITION_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing team prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + VALID_TEAM_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing location prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + VALID_LOCATION_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing numberOfLocations prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + VALID_NUMBER_OF_POSITIONS_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                expectedMessage);

        // missing tags prefix
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + VALID_SKILL_JAVASCRIPT,
                expectedMessage);
    }

    @Test
    public void parse_invalidValue_failure() {
        // invalid position
        assertParseFailure(parser, INVALID_POSITION_DESC + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Position.MESSAGE_POSITION_CONSTRAINTS);

        // invalid team
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + INVALID_TEAM_DESC
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Team.MESSAGE_TEAM_CONSTRAINTS);

        // invalid location
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + INVALID_LOCATION_DESC + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN + SKILL_DESC_JAVASCRIPT,
                Location.MESSAGE_LOCATION_CONSTRAINTS);

        // invalid numberOfPositions
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + INVALID_NUMBER_OF_POSITIONS_DESC + SKILL_DESC_JAVASCRIPT,
                NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS);

        // invalid skill
        assertParseFailure(parser, POSITION_DESC_DEVELOPER_INTERN + TEAM_DESC_DEVELOPER_INTERN
                + LOCATION_DESC_DEVELOPER_INTERN + NUMBER_OF_POSITIONS_DESC_DEVELOPER_INTERN
                + INVALID_SKILL_DESC, Skill.MESSAGE_SKILL_CONSTRAINTS);
    }
}
```
###### /java/seedu/address/logic/parser/job/JobDeleteCommandParserTest.java
``` java
package seedu.address.logic.parser.job;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.logic.commands.job.JobDeleteCommand;

public class JobDeleteCommandParserTest {

    private JobDeleteCommandParser parser = new JobDeleteCommandParser();

    @Test
    public void parse_validArgs_returnsJobDeleteCommand() {
        assertParseSuccess(parser, "1", new JobDeleteCommand(INDEX_FIRST));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, JobDeleteCommand.MESSAGE_USAGE));
    }

}
```
###### /java/seedu/address/logic/parser/LinkedInCommandParserTest.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseFailure;
import static seedu.address.logic.parser.CommandParserTestUtil.assertParseSuccess;
import static seedu.address.testutil.TypicalIndexes.INDEX_FIRST;

import org.junit.Test;

import seedu.address.logic.commands.person.LinkedInCommand;
import seedu.address.logic.parser.person.LinkedInCommandParser;

public class LinkedInCommandParserTest {

    private LinkedInCommandParser parser = new LinkedInCommandParser();

    @Test
    public void parse_validArgs_returnsLinkedInCommand() {
        assertParseSuccess(parser, "1", new LinkedInCommand(INDEX_FIRST));
    }

    @Test
    public void parse_invalidArgs_throwsParseException() {
        assertParseFailure(parser, "a", String.format(MESSAGE_INVALID_COMMAND_FORMAT, LinkedInCommand.MESSAGE_USAGE));
    }
}
```
###### /java/seedu/address/logic/parser/AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_addJob() throws Exception {
        Job job = new JobBuilder().build();
        JobAddCommand command = (JobAddCommand) parser.parseCommand(JobUtil.getJobAddCommand(job));
        assertEquals(new JobAddCommand(job), command);
    }

```
###### /java/seedu/address/logic/parser/AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_deleteJob() throws Exception {
        JobDeleteCommand command = (JobDeleteCommand) parser.parseCommand(
                JobDeleteCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased());
        assertEquals(new JobDeleteCommand(INDEX_FIRST), command);
    }

```
###### /java/seedu/address/logic/parser/AddressBookParserTest.java
``` java
    @Test
    public void parseCommand_linkedIn() throws Exception {
        LinkedInCommand command = (LinkedInCommand) parser.parseCommand(
                LinkedInCommand.COMMAND_WORD + " " + INDEX_FIRST.getOneBased());
        assertEquals(new LinkedInCommand(INDEX_FIRST), command);
    }

```
###### /java/seedu/address/model/job/NumberOfPositionsTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class NumberOfPositionsTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new NumberOfPositions(null));
    }

    @Test
    public void constructor_invalidNumberOfPositions_throwsIllegalArgumentException() {
        String invalidNumberOfPositions = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new NumberOfPositions(invalidNumberOfPositions));
    }

    @Test
    public void isValidNumberOfPositions() {
        // null location
        Assert.assertThrows(NullPointerException.class, () -> NumberOfPositions.isValidNumberOfPositions(null));

        // invalid locations
        assertFalse(NumberOfPositions.isValidNumberOfPositions("")); // empty string
        assertFalse(NumberOfPositions.isValidNumberOfPositions(" ")); // spaces only
        assertFalse(NumberOfPositions.isValidNumberOfPositions("abc")); // non-numeric
        assertFalse(NumberOfPositions.isValidNumberOfPositions("9011p041")); // alphabets within digits
        assertFalse(NumberOfPositions.isValidNumberOfPositions("9312 1534")); // spaces within digits

        // valid locations
        assertTrue(NumberOfPositions.isValidNumberOfPositions("1")); // one digit
        assertTrue(NumberOfPositions.isValidNumberOfPositions("33"));
        assertTrue(NumberOfPositions.isValidNumberOfPositions("3545")); // long number of positions
    }
}
```
###### /java/seedu/address/model/job/TeamTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class TeamTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Team(null));
    }

    @Test
    public void constructor_invalidTeam_throwsIllegalArgumentException() {
        String invalidTeam = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Team(invalidTeam));
    }

    @Test
    public void isValidTeam() {
        // null team
        Assert.assertThrows(NullPointerException.class, () -> Team.isValidTeam(null));

        // invalid team
        assertFalse(Team.isValidTeam("")); // empty string
        assertFalse(Team.isValidTeam(" ")); // spaces only
        assertFalse(Team.isValidTeam("^")); // only non-alphanumeric characters
        assertFalse(Team.isValidTeam("management*")); // contains non-alphanumeric characters

        // valid team
        assertTrue(Team.isValidTeam("frontend")); // alphabets only
        assertTrue(Team.isValidTeam("12345")); // numbers only
        assertTrue(Team.isValidTeam("2nd development")); // alphanumeric characters
        assertTrue(Team.isValidTeam("Cloud Services")); // with capital letters
        assertTrue(Team.isValidTeam("Frontend Web Development")); // long teams
    }
}
```
###### /java/seedu/address/model/job/LocationTest.java
``` java
package seedu.address.model.job;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertFalse;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class LocationTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Location(null));
    }

    @Test
    public void constructor_invalidLocation_throwsIllegalArgumentException() {
        String invalidLocation = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Location(invalidLocation));
    }

    @Test
    public void isValidLocation() {
        // null location
        Assert.assertThrows(NullPointerException.class, () -> Location.isValidLocation(null));

        // invalid locations
        assertFalse(Location.isValidLocation("")); // empty string
        assertFalse(Location.isValidLocation(" ")); // spaces only

        // valid locations
        assertTrue(Location.isValidLocation("Singapore"));
        assertTrue(Location.isValidLocation("-")); // one character
        assertTrue(Location.isValidLocation("Leng Inc; 1234 Market St; San Francisco CA 2349879; USA")); // long address
    }

}
```
###### /java/seedu/address/model/job/PositionTest.java
``` java
package seedu.address.model.job;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class PositionTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Position(null));
    }

    @Test
    public void constructor_invalidPosition_throwsIllegalArgumentException() {
        String invalidPosition = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Position(invalidPosition));
    }

    @Test
    public void isValidPosition() {
        // null position
        Assert.assertThrows(NullPointerException.class, () -> Position.isValidPosition(null));

        // invalid position
        assertFalse(Position.isValidPosition("")); // empty string
        assertFalse(Position.isValidPosition(" ")); // spaces only
        assertFalse(Position.isValidPosition("^")); // only non-alphanumeric characters
        assertFalse(Position.isValidPosition("engineer*")); // contains non-alphanumeric characters

        // valid position
        assertTrue(Position.isValidPosition("intern")); // alphabets only
        assertTrue(Position.isValidPosition("12345")); // numbers only
        assertTrue(Position.isValidPosition("2nd associate")); // alphanumeric characters
        assertTrue(Position.isValidPosition("Software Engineer")); // with capital letters
        assertTrue(Position.isValidPosition("Computer Science undergraduate")); // long positions
    }
}
```
###### /java/seedu/address/model/person/CompanyTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class CompanyTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new Company(null));
    }

    @Test
    public void constructor_invalidCompany_throwsIllegalArgumentException() {
        String invalidCompany = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new Company(invalidCompany));
    }

    @Test
    public void isValidCompany() {
        // null company
        Assert.assertThrows(NullPointerException.class, () -> Company.isValidCompany(null));

        // invalid company
        assertFalse(Company.isValidCompany("")); // empty string
        assertFalse(Company.isValidCompany(" ")); // spaces only
        assertFalse(Company.isValidCompany("^")); // only non-alphanumeric characters
        assertFalse(Company.isValidCompany("google*")); // contains non-alphanumeric characters

        // valid company
        assertTrue(Company.isValidCompany("google")); // alphabets only
        assertTrue(Company.isValidCompany("12345")); // numbers only
        assertTrue(Company.isValidCompany("facebook 2nd")); // alphanumeric characters
        assertTrue(Company.isValidCompany("Capital Ventures")); // with capital letters
        assertTrue(Company.isValidCompany("Google Services Pvt Ltd")); // long companys
    }

    private void assertTrue(boolean google) {
    }
}
```
###### /java/seedu/address/model/person/CurrentPositionTest.java
``` java
package seedu.address.model.person;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.testutil.Assert;

public class CurrentPositionTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        Assert.assertThrows(NullPointerException.class, () -> new CurrentPosition(null));
    }

    @Test
    public void constructor_invalidCurrentPosition_throwsIllegalArgumentException() {
        String invalidCurrentPosition = "";
        Assert.assertThrows(IllegalArgumentException.class, () -> new CurrentPosition(invalidCurrentPosition));
    }

    @Test
    public void isValidCurrentPosition() {
        // null current position
        Assert.assertThrows(NullPointerException.class, () -> CurrentPosition.isValidCurrentPosition(null));

        // invalid current position
        assertFalse(CurrentPosition.isValidCurrentPosition("")); // empty string
        assertFalse(CurrentPosition.isValidCurrentPosition(" ")); // spaces only
        assertFalse(CurrentPosition.isValidCurrentPosition("^")); // only non-alphanumeric characters
        assertFalse(CurrentPosition.isValidCurrentPosition("engineer*")); // contains non-alphanumeric characters

        // valid current position
        assertTrue(CurrentPosition.isValidCurrentPosition("engineer")); // alphabets only
        assertTrue(CurrentPosition.isValidCurrentPosition("12345")); // numbers only
        assertTrue(CurrentPosition.isValidCurrentPosition("2nd year student")); // alphanumeric characters
        assertTrue(CurrentPosition.isValidCurrentPosition("Marketing Intern")); // with capital letters
        assertTrue(CurrentPosition.isValidCurrentPosition("First year undergraduate student")); // long position
    }
}
```
###### /java/seedu/address/model/UniqueJobListTest.java
``` java
package seedu.address.model;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import seedu.address.model.job.UniqueJobList;

public class UniqueJobListTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void asObservableList_modifyList_throwsUnsupportedOperationException() {
        UniqueJobList uniqueJobList = new UniqueJobList();
        thrown.expect(UnsupportedOperationException.class);
        uniqueJobList.asObservableList().remove(0);
    }
}
```
###### /java/seedu/address/model/ModelManagerTest.java
``` java
    @Test
    public void getFilteredJobList_modifyList_throwsUnsupportedOperationException() {
        ModelManager modelManager = new ModelManager();
        thrown.expect(UnsupportedOperationException.class);
        modelManager.getFilteredJobList().remove(0);
    }

```
###### /java/seedu/address/commons/util/XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithMissingJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                MISSING_JOB_FIELD_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(null, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### /java/seedu/address/commons/util/XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithInvalidJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                INVALID_JOB_FIELD_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(INVALID_POSITION, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### /java/seedu/address/commons/util/XmlUtilTest.java
``` java
    @Test
    public void xmlAdaptedJobFromFile_fileWithValidJobField_validResult() throws Exception {
        XmlAdaptedJob actualJob = XmlUtil.getDataFromFile(
                VALID_JOB_FILE, XmlAdaptedJobWithRootElement.class);
        XmlAdaptedJob expectedJob = new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION,
                VALID_NUMBER_OF_POSITIONS, VALID_SKILLS);
        assertEquals(expectedJob, actualJob);
    }

```
###### /java/seedu/address/commons/util/XmlUtilTest.java
``` java
    /**
     * Test class annotated with {@code XmlRootElement} to allow unmarshalling of .xml data to {@code XmlAdaptedJob}
     * objects.
     */
    @XmlRootElement(name = "job")
    private static class XmlAdaptedJobWithRootElement extends XmlAdaptedJob {}
}
```
###### /java/seedu/address/storage/XmlAddressBookStorageTest.java
``` java
    @Test
    public void readAddressBook_invalidJobAddressBook_throwDataConversionException() throws Exception {
        thrown.expect(DataConversionException.class);
        readAddressBook("invalidJobAddressBook.xml");
    }

```
###### /java/seedu/address/storage/XmlAddressBookStorageTest.java
``` java
    @Test
    public void readAddressBook_invalidAndValidJobAddressBook_throwDataConversionException() throws Exception {
        thrown.expect(DataConversionException.class);
        readAddressBook("invalidAndValidJobAddressBook.xml");
    }

```
###### /java/seedu/address/storage/XmlSerializableAddressBookTest.java
``` java
    @Test
    public void toModelType_typicalJobsFile_success() throws Exception {
        XmlSerializableAddressBook dataFromFile = XmlUtil.getDataFromFile(TYPICAL_JOBS_FILE,
                XmlSerializableAddressBook.class);
        AddressBook addressBookFromFile = dataFromFile.toModelType();
        AddressBook typicalJobsAddressBook = TypicalJobs.getTypicalAddressBook();
        assertEquals(addressBookFromFile, typicalJobsAddressBook);
    }

```
###### /java/seedu/address/storage/XmlAdaptedJobTest.java
``` java
package seedu.address.storage;

import static org.junit.Assert.assertEquals;
import static seedu.address.storage.XmlAdaptedJob.MISSING_FIELD_MESSAGE_FORMAT;
import static seedu.address.testutil.TypicalJobs.MARKETING_INTERN;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.testutil.Assert;

public class XmlAdaptedJobTest {

    private static final String INVALID_POSITION = "Associ@te";
    private static final String INVALID_TEAM = "Engineering#";
    private static final String INVALID_LOCATION = " ";
    private static final String INVALID_NUMBER_OF_POSITIONS = "a12";
    private static final String INVALID_TAG = "C and Java";

    private static final String VALID_POSITION = MARKETING_INTERN.getPosition().toString();
    private static final String VALID_TEAM = MARKETING_INTERN.getTeam().toString();
    private static final String VALID_LOCATION = MARKETING_INTERN.getLocation().toString();
    private static final String VALID_NUMBER_OF_POSITIONS = MARKETING_INTERN.getNumberOfPositions().toString();
    private static final List<XmlAdaptedSkill> VALID_TAGS = MARKETING_INTERN.getSkills().stream()
            .map(XmlAdaptedSkill::new)
            .collect(Collectors.toList());

    @Test
    public void toModelType_validJobDetails_returnsJob() throws Exception {
        XmlAdaptedJob job = new XmlAdaptedJob(MARKETING_INTERN);
        assertEquals(MARKETING_INTERN, job.toModelType());
    }

    @Test
    public void toModelType_invalidPosition_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(INVALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Position.MESSAGE_POSITION_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullPosition_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(null, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Position.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidTeam_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, INVALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Team.MESSAGE_TEAM_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullTeam_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, null, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Team.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidLocation_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, INVALID_LOCATION, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = Location.MESSAGE_LOCATION_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullLocation_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, null, VALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, Location.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_invalidNumberOfPositions_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, INVALID_NUMBER_OF_POSITIONS, VALID_TAGS);
        String expectedMessage = NumberOfPositions.MESSAGE_NUMBER_OF_POSITIONS_CONSTRAINTS;
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_nullNumberOfPositions_throwsIllegalValueException() {
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, null, VALID_TAGS);
        String expectedMessage = String.format(MISSING_FIELD_MESSAGE_FORMAT, NumberOfPositions.class.getSimpleName());
        Assert.assertThrows(IllegalValueException.class, expectedMessage, job::toModelType);
    }

    @Test
    public void toModelType_emptyTags_throwsIllegalValueException() {
        List<XmlAdaptedSkill> emptyTags = new ArrayList<>();
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, emptyTags);
        Assert.assertThrows(IllegalValueException.class, job::toModelType);
    }

    @Test
    public void toModelType_invalidTags_throwsIllegalValueException() {
        List<XmlAdaptedSkill> invalidTags = new ArrayList<>(VALID_TAGS);
        invalidTags.add(new XmlAdaptedSkill(INVALID_TAG));
        XmlAdaptedJob job =
                new XmlAdaptedJob(VALID_POSITION, VALID_TEAM, VALID_LOCATION, VALID_NUMBER_OF_POSITIONS, invalidTags);
        Assert.assertThrows(IllegalValueException.class, job::toModelType);
    }

}
```
###### /java/seedu/address/ui/DetailsPanelTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.DetailsPanelHandle;
import seedu.address.commons.events.ui.SwitchTabRequestEvent;

public class DetailsPanelTest extends GuiUnitTest {

    private DetailsPanelHandle detailsPanelHandle;

    @Before
    public void setUp() {
        DetailsPanel detailsPanel = new DetailsPanel();
        uiPartRule.setUiPart(detailsPanel);

        detailsPanelHandle = new DetailsPanelHandle(getChildNode(detailsPanel.getRoot(), "#tabPane"));
    }

    @Test
    public void display() {
        // default tab
        assertEquals(0, detailsPanelHandle.getCurrentTab());

        postNow(new SwitchTabRequestEvent(1));
        assertEquals(1, detailsPanelHandle.getCurrentTab());
        postNow(new SwitchTabRequestEvent(0));
        assertEquals(0, detailsPanelHandle.getCurrentTab());
        postNow(new SwitchTabRequestEvent(0));
        assertEquals(0, detailsPanelHandle.getCurrentTab());
    }
}
```
###### /java/seedu/address/ui/JobCardTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardDisplaysJob;

import org.junit.Test;

import guitests.guihandles.JobCardHandle;
import seedu.address.model.job.Job;
import seedu.address.testutil.JobBuilder;

public class JobCardTest extends GuiUnitTest {
    @Test
    public void display() {

        // sample job
        Job job = new JobBuilder().build();
        JobCard jobCard = new JobCard(job, 1);
        uiPartRule.setUiPart(jobCard);
        assertCardDisplay(jobCard, job, 1);
    }

    @Test
    public void equals() {
        Job job = new JobBuilder().build();
        JobCard jobCard = new JobCard(job, 0);

        // same job, same index -> returns true
        JobCard copy = new JobCard(job, 0);
        assertTrue(jobCard.equals(copy));

        // same object -> returns true
        assertTrue(jobCard.equals(jobCard));

        // null -> returns false
        assertFalse(jobCard.equals(null));

        // different types -> returns false
        assertFalse(jobCard.equals(0));

        // different job, same index -> returns false
        Job differentJob = new JobBuilder().withPosition("differentPosition").build();
        assertFalse(jobCard.equals(new JobCard(differentJob, 0)));

        // same job, different index -> returns false
        assertFalse(jobCard.equals(new JobCard(job, 1)));
    }

    /**
     * Asserts that {@code jobCard} displays the details of {@code expectedJob} correctly and matches
     * {@code expectedId}.
     */
    private void assertCardDisplay(JobCard jobCard, Job expectedJob, int expectedId) {
        guiRobot.pauseForHuman();

        JobCardHandle jobCardHandle = new JobCardHandle(jobCard.getRoot());

        // verify id is displayed correctly
        assertEquals(Integer.toString(expectedId) + ". ", jobCardHandle.getId());

        // verify job details are displayed correctly
        assertCardDisplaysJob(expectedJob, jobCardHandle);
    }
}
```
###### /java/seedu/address/ui/JobListPanelTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;
import static seedu.address.testutil.TypicalIndexes.INDEX_SECOND;
import static seedu.address.testutil.TypicalJobs.getTypicalJobs;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardDisplaysJob;
import static seedu.address.ui.testutil.GuiTestAssert.assertCardEquals;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.JobCardHandle;
import guitests.guihandles.JobListPanelHandle;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.events.ui.JumpToJobListRequestEvent;
import seedu.address.model.job.Job;

public class JobListPanelTest extends GuiUnitTest {
    private static final ObservableList<Job> TYPICAL_JOBS =
            FXCollections.observableList(getTypicalJobs());

    private static final JumpToJobListRequestEvent JUMP_TO_SECOND_EVENT = new JumpToJobListRequestEvent(INDEX_SECOND);

    private JobListPanelHandle jobListPanelHandle;

    @Before
    public void setUp() {
        JobListPanel jobListPanel = new JobListPanel(TYPICAL_JOBS);
        uiPartRule.setUiPart(jobListPanel);

        jobListPanelHandle = new JobListPanelHandle(getChildNode(jobListPanel.getRoot(),
                JobListPanelHandle.JOB_LIST_VIEW_ID));
    }

    @Test
    public void display() {
        for (int i = 0; i < TYPICAL_JOBS.size(); i++) {
            jobListPanelHandle.navigateToCard(TYPICAL_JOBS.get(i));
            Job expectedJob = TYPICAL_JOBS.get(i);
            JobCardHandle actualCard = jobListPanelHandle.getJobCardHandle(i);

            assertCardDisplaysJob(expectedJob, actualCard);
            assertEquals(Integer.toString(i + 1) + ". ", actualCard.getId());
        }
    }

    @Test
    public void handleJumpToListRequestEvent() {
        postNow(JUMP_TO_SECOND_EVENT);
        guiRobot.pauseForHuman();

        JobCardHandle expectedCard = jobListPanelHandle.getJobCardHandle(INDEX_SECOND.getZeroBased());
        JobCardHandle selectedCard = jobListPanelHandle.getHandleToSelectedCard();
        assertCardEquals(expectedCard, selectedCard);
    }

}
```
###### /java/seedu/address/ui/ContactDetailsDisplayTest.java
``` java
package seedu.address.ui;

import static org.junit.Assert.assertEquals;
import static seedu.address.testutil.EventsUtil.postNow;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.ContactDetailsDisplayHandle;
import seedu.address.commons.events.ui.PersonPanelSelectionChangedEvent;
import seedu.address.model.person.Person;
import seedu.address.testutil.PersonBuilder;

public class ContactDetailsDisplayTest extends GuiUnitTest {

    private ContactDetailsDisplayHandle contactDetailsDisplayHandle;

    @Before
    public void setUp() {
        ContactDetailsDisplay contactDetailsDisplay = new ContactDetailsDisplay();
        uiPartRule.setUiPart(contactDetailsDisplay);

        contactDetailsDisplayHandle = new ContactDetailsDisplayHandle(contactDetailsDisplay.getRoot());
    }

    @Test
    public void display() {

        // new result received
        Person person = new PersonBuilder().build();
        PersonCard personCard = new PersonCard(person, 0);

        postNow(new PersonPanelSelectionChangedEvent(personCard));
        guiRobot.pauseForHuman();

        assertEquals(person.getName().fullName, contactDetailsDisplayHandle.getName());
        assertEquals(person.getName().fullName, contactDetailsDisplayHandle.getFullName());
        assertEquals(person.getPhone().value, contactDetailsDisplayHandle.getPhone());
        assertEquals(person.getEmail().value, contactDetailsDisplayHandle.getEmail());
    }
}
```
###### /java/seedu/address/testutil/JobUtil.java
``` java
package seedu.address.testutil;

import static seedu.address.logic.parser.CliSyntax.PREFIX_LOCATION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_NUMBER_OF_POSITIONS;
import static seedu.address.logic.parser.CliSyntax.PREFIX_POSITION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_SKILL;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TEAM;

import seedu.address.logic.commands.job.JobAddCommand;
import seedu.address.model.job.Job;

/**
 * A utility class for Job.
 */
public class JobUtil {

    /**
     * Returns an add command string for adding the {@code job}.
     */
    public static String getJobAddCommand(Job job) {
        return JobAddCommand.COMMAND_WORD + " " + getJobDetails(job);
    }

    /**
     * Returns the part of command string for the given {@code job}'s details.
     */
    public static String getJobDetails(Job job) {
        StringBuilder sb = new StringBuilder();
        sb.append(PREFIX_POSITION + job.getPosition().value + " ");
        sb.append(PREFIX_TEAM + job.getTeam().value + " ");
        sb.append(PREFIX_LOCATION + job.getLocation().value + " ");
        sb.append(PREFIX_NUMBER_OF_POSITIONS + job.getNumberOfPositions().value + " ");
        job.getSkills().stream().forEach(s -> sb.append(PREFIX_SKILL + s.skillName + " "));
        return sb.toString();
    }
}
```
###### /java/seedu/address/testutil/JobBuilder.java
``` java
package seedu.address.testutil;

import java.util.HashSet;
import java.util.Set;

import seedu.address.model.job.Job;
import seedu.address.model.job.Location;
import seedu.address.model.job.NumberOfPositions;
import seedu.address.model.job.Position;
import seedu.address.model.job.Team;
import seedu.address.model.skill.Skill;
import seedu.address.model.util.SampleDataUtil;

/**
 * A utility class to help with building Person objects.
 */
public class JobBuilder {

    public static final String DEFAULT_POSITION = "Hardware Engineer";
    public static final String DEFAULT_TEAM = "Microprocessor";
    public static final String DEFAULT_LOCATION = "Singapore";
    public static final String DEFAULT_NUMBER_OF_POSITIONS = "2";
    public static final String DEFAULT_TAGS = "C++";

    private Position position;
    private Team team;
    private Location location;
    private NumberOfPositions numberOfPositions;
    private Set<Skill> skills;

    public JobBuilder() {
        position = new Position(DEFAULT_POSITION);
        team = new Team(DEFAULT_TEAM);
        location = new Location(DEFAULT_LOCATION);
        numberOfPositions = new NumberOfPositions(DEFAULT_NUMBER_OF_POSITIONS);
        skills = SampleDataUtil.getSkillSet(DEFAULT_TAGS);
    }

    /**
     * Initializes the JobBuilder with the data of {@code jobToCopy}.
     */
    public JobBuilder(Job jobToCopy) {
        position = jobToCopy.getPosition();
        team = jobToCopy.getTeam();
        location = jobToCopy.getLocation();
        numberOfPositions = jobToCopy.getNumberOfPositions();
        skills = new HashSet<>(jobToCopy.getSkills());
    }

    /**
     * Sets the {@code Position} of the {@code Job} that we are building.
     */
    public JobBuilder withPosition(String position) {
        this.position = new Position(position);
        return this;
    }

    /**
     * Sets the {@code Team} of the {@code Job} that we are building.
     */
    public JobBuilder withTeam(String team) {
        this.team = new Team(team);
        return this;
    }

    /**
     * Sets the {@code Location} of the {@code Job} that we are building.
     */
    public JobBuilder withLocation(String location) {
        this.location = new Location(location);
        return this;
    }

    /**
     * Sets the {@code NumberOfPositions} of the {@code Job} that we are building.
     */
    public JobBuilder withNumberOfPositions(String numberOfPositions) {
        this.numberOfPositions = new NumberOfPositions(numberOfPositions);
        return this;
    }

    /**
     * Parses the {@code skills} into a {@code Set<Skill>} and set it to the {@code Job} that we are building.
     */
    public JobBuilder withSkills(String ... skills) {
        this.skills = SampleDataUtil.getSkillSet(skills);
        return this;
    }

    public Job build() {
        return new Job(position, team, location, numberOfPositions, skills);
    }
}
```
###### /java/seedu/address/testutil/TypicalJobs.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import seedu.address.model.AddressBook;
import seedu.address.model.job.Job;
import seedu.address.model.job.exceptions.DuplicateJobException;

/**
 * A utility class containing a list of {@code Job} objects to be used in tests.
 */
public class TypicalJobs {

    public static final Job SOFTWARE_ENGINEER = new JobBuilder().withPosition("Software Engineer")
            .withTeam("Cloud Services").withLocation("Singapore").withNumberOfPositions("2")
            .withSkills("Java", "Algorithms").build();
    public static final Job MARKETING_INTERN = new JobBuilder().withPosition("Marketing Intern")
            .withTeam("Marketing").withLocation("Kuala Lampur, Malaysia").withNumberOfPositions("1")
            .withSkills("Excel", "Writing").build();
    public static final Job DEVOPS_ENGINEER = new JobBuilder().withPosition("DevOps Engineer")
            .withTeam("DevOps").withLocation("Singapore").withNumberOfPositions("3")
            .withSkills("AWS", "SQL-Server").build();
    public static final Job PRODUCT_MANAGER = new JobBuilder().withPosition("Product Manager")
            .withTeam("Mobile Products").withLocation("India").withNumberOfPositions("1")
            .withSkills("UI/UX", "Testing").build();

    // Manually added
    public static final Job ANALYST = new JobBuilder().withPosition("Analyst").withTeam("Data Science")
            .withLocation("New Delhi, India").withNumberOfPositions("5").withSkills("Excel").build();
    public static final Job DEVELOPER_INTERN = new JobBuilder().withPosition("Developer Intern")
            .withLocation("Jakarta, Indonesia").withTeam("Web Development").withNumberOfPositions("2")
            .withSkills("JavaScript", "Algorithms").build();

    // Manually added - Job's details found in {@code CommandTestUtil}
    public static final Job INTERN = new JobBuilder().withPosition("Intern").withTeam("HR")
            .withLocation("Singapore").withNumberOfPositions("1").withSkills("Word").build();
    public static final Job DATA_SCIENTIST = new JobBuilder().withPosition("Data Scientist").withTeam("Data Science")
            .withLocation("Singapore").withNumberOfPositions("1").withSkills("Analysis").build();

    private TypicalJobs() {} // prevents instantiation

    /**
     * Returns an {@code AddressBook} with all the typical persons.
     */
    public static AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        for (Job job : getTypicalJobs()) {
            try {
                ab.addJob(job);
            } catch (DuplicateJobException e) {
                throw new AssertionError("not possible");
            }
        }
        return ab;
    }

    public static List<Job> getTypicalJobs() {
        return new ArrayList<>(Arrays.asList(SOFTWARE_ENGINEER, MARKETING_INTERN, DEVOPS_ENGINEER, PRODUCT_MANAGER));
    }
}

```
###### /java/guitests/guihandles/ContactDetailsDisplayHandle.java
``` java
package guitests.guihandles;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;

/**
 * A handle to the {@code ContactDetailsDisplay} in the GUI.
 */
public class ContactDetailsDisplayHandle extends NodeHandle<Node> {

    private static final String NAME_FIELD_ID = "#name";
    private static final String LIST_ID = "#values";
    //TODO: include Tags

    private final Label nameLabel;
    private final ListView<Label> valuesList;

    public ContactDetailsDisplayHandle(Node contactDetailsDisplayNode) {
        super(contactDetailsDisplayNode);

        this.nameLabel = getChildNode(NAME_FIELD_ID);
        this.valuesList = getChildNode(LIST_ID);
    }

    public String getName() {
        return nameLabel.getText();
    }

    public String getFullName() {
        return valuesList.getItems().get(0).getText();
    }

    public String getPhone() {
        return valuesList.getItems().get(1).getText();
    }

    public String getEmail() {
        return valuesList.getItems().get(2).getText();
    }

    public String getAddress() {
        return valuesList.getItems().get(3).getText();
    }
}
```
###### /java/guitests/guihandles/JobListPanelHandle.java
``` java
package guitests.guihandles;

import java.util.List;
import java.util.Optional;

import javafx.scene.control.ListView;
import seedu.address.model.job.Job;
import seedu.address.ui.JobCard;

/**
 * Provides a handle for {@code JobListPanel} containing the list of {@code JobCard}.
 */
public class JobListPanelHandle extends NodeHandle<ListView<JobCard>> {
    public static final String JOB_LIST_VIEW_ID = "#jobListView";

    private Optional<JobCard> lastRememberedSelectedJobCard;

    public JobListPanelHandle(ListView<JobCard> jobListPanelNode) {
        super(jobListPanelNode);
    }

    /**
     * Returns a handle to the selected {@code JobCardHandle}.
     * A maximum of 1 item can be selected at any time.
     * @throws AssertionError if no card is selected, or more than 1 card is selected.
     */
    public JobCardHandle getHandleToSelectedCard() {
        List<JobCard> jobList = getRootNode().getSelectionModel().getSelectedItems();

        if (jobList.size() != 1) {
            throw new AssertionError("Job list size expected 1.");
        }

        return new JobCardHandle(jobList.get(0).getRoot());
    }

    /**
     * Returns the index of the selected card.
     */
    public int getSelectedCardIndex() {
        return getRootNode().getSelectionModel().getSelectedIndex();
    }

    /**
     * Returns true if a card is currently selected.
     */
    public boolean isAnyCardSelected() {
        List<JobCard> selectedCardsList = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedCardsList.size() > 1) {
            throw new AssertionError("Card list size expected 0 or 1.");
        }

        return !selectedCardsList.isEmpty();
    }

    /**
     * Navigates the listview to display and select the job.
     */
    public void navigateToCard(Job job) {
        List<JobCard> cards = getRootNode().getItems();
        Optional<JobCard> matchingCard = cards.stream().filter(card -> card.job.equals(job)).findFirst();

        if (!matchingCard.isPresent()) {
            throw new IllegalArgumentException("Job does not exist.");
        }

        guiRobot.interact(() -> {
            getRootNode().scrollTo(matchingCard.get());
            getRootNode().getSelectionModel().select(matchingCard.get());
        });
        guiRobot.pauseForHuman();
    }

    /**
     * Returns the job card handle of a job associated with the {@code index} in the list.
     */
    public JobCardHandle getJobCardHandle(int index) {
        return getJobCardHandle(getRootNode().getItems().get(index).job);
    }

    /**
     * Returns the {@code JobCardHandle} of the specified {@code job} in the list.
     */
    public JobCardHandle getJobCardHandle(Job job) {
        Optional<JobCardHandle> handle = getRootNode().getItems().stream()
                .filter(card -> card.job.equals(job))
                .map(card -> new JobCardHandle(card.getRoot()))
                .findFirst();
        return handle.orElseThrow(() -> new IllegalArgumentException("Job does not exist."));
    }

    /**
     * Selects the {@code JobCard} at {@code index} in the list.
     */
    public void select(int index) {
        getRootNode().getSelectionModel().select(index);
    }

    /**
     * Remembers the selected {@code JobCard} in the list.
     */
    public void rememberSelectedJobCard() {
        List<JobCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            lastRememberedSelectedJobCard = Optional.empty();
        } else {
            lastRememberedSelectedJobCard = Optional.of(selectedItems.get(0));
        }
    }

    /**
     * Returns true if the selected {@code JobCard} is different from the value remembered by the most recent
     * {@code rememberSelectedJobCard()} call.
     */
    public boolean isSelectedJobCardChanged() {
        List<JobCard> selectedItems = getRootNode().getSelectionModel().getSelectedItems();

        if (selectedItems.size() == 0) {
            return lastRememberedSelectedJobCard.isPresent();
        } else {
            return !lastRememberedSelectedJobCard.isPresent()
                    || !lastRememberedSelectedJobCard.get().equals(selectedItems.get(0));
        }
    }

    /**
     * Returns the size of the list.
     */
    public int getListSize() {
        return getRootNode().getItems().size();
    }
}
```
###### /java/guitests/guihandles/DetailsPanelHandle.java
``` java
package guitests.guihandles;

import javafx.scene.control.TabPane;

/**
 * A handle to the {@code DetailsPanelHandle} in the GUI.
 */
public class DetailsPanelHandle extends NodeHandle<TabPane> {

    public DetailsPanelHandle(TabPane detailsPanel) {
        super(detailsPanel);
    }

    public int getCurrentTab() {
        return getRootNode().getSelectionModel().getSelectedIndex();
    }
}
```
###### /java/guitests/guihandles/JobCardHandle.java
``` java
package guitests.guihandles;

import java.util.List;
import java.util.stream.Collectors;

import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;

/**
 * Provides a handle to a job card in the job list panel.
 */
public class JobCardHandle extends NodeHandle<Node> {
    private static final String ID_FIELD_ID = "#id";
    private static final String POSITION_FIELD_ID = "#position";
    private static final String TEAM_FIELD_ID = "#team";
    private static final String LOCATION_FIELD_ID = "#jobLocation";
    private static final String NUMBER_OF_POSITIONS_FIELD_ID = "#numberOfPositions";
    private static final String TAGS_FIELD_ID = "#skills";

    private final Label idLabel;
    private final Label positionLabel;
    private final Label teamLabel;
    private final Label locationLabel;
    private final Label numberOfPositionsLabel;
    private final List<Label> tagLabels;

    public JobCardHandle(Node cardNode) {
        super(cardNode);

        this.idLabel = getChildNode(ID_FIELD_ID);
        this.positionLabel = getChildNode(POSITION_FIELD_ID);
        this.teamLabel = getChildNode(TEAM_FIELD_ID);
        this.locationLabel = getChildNode(LOCATION_FIELD_ID);
        this.numberOfPositionsLabel = getChildNode(NUMBER_OF_POSITIONS_FIELD_ID);

        Region tagsContainer = getChildNode(TAGS_FIELD_ID);
        this.tagLabels = tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(Label.class::cast)
                .collect(Collectors.toList());
    }

    public String getId() {
        return idLabel.getText();
    }

    public String getPosition() {
        return positionLabel.getText();
    }

    public String getTeam() {
        return teamLabel.getText();
    }

    public String getLocation() {
        return locationLabel.getText();
    }

    public String getNumberOfPositions() {
        return numberOfPositionsLabel.getText();
    }

    public List<String> getSkills() {
        return tagLabels
                .stream()
                .map(Label::getText)
                .collect(Collectors.toList());
    }

    public List<String> getSkillStyleClasses(String tag) {
        return tagLabels
                .stream()
                .filter(label -> label.getText().equals(tag))
                .map(Label::getStyleClass)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("No such skill."));
    }
}
```
